# BEST-RTPC: 实时等离子体计算平台

## BEST Real-Time Plasma Computation Platform

**版本**: V1.0  
**日期**: 2026-02-13  
**基于**: AMD Radeon AI PRO R9700 (RDNA 4) + HIP  
**架构**: 分布式双 GPU（PCS + ECRH 独立服务器）

---

## 1. 项目概述

### 1.1 背景

BEST 全超导托卡马克装置的等离子体控制系统（PCS）和 ECRH 系统面临实时计算瓶颈：

| 计算任务 | 当前实现 | 延迟 | 目标延迟 |
|---------|---------|------|---------|
| 平衡重建 (EFIT) | CPU 单核迭代 | 5–10 ms | < 1 ms |
| 射线追踪 | CPU rt-TORBEAM | 15–20 ms | < 1 ms |
| **端到端** | **串行 CPU** | **~25 ms** | **< 2 ms** |

### 1.2 解决方案

采用 **分布式双 GPU 架构**，在 PCS 和 ECRH 各部署一块 AMD Radeon AI PRO R9700：

```
诊断系统 ──→ [GPU #1: GPU-EFIT] ──RFM──→ [GPU #2: 射线追踪] ──→ Launcher
              PCS 机柜                      ECRH-MC 机柜
              0.6 ms                        0.5 ms
                        端到端: ~1.4 ms (加速 ~18×)
```

### 1.3 本项目 `best-rtpc` 的定位

本项目是上述方案的 **HIP 参考实现**，包含：

- GPU-EFIT：P-EFIT 5 步算法的 HIP kernel 实现
- GPU 射线追踪：Hamilton 射线方程 + 自适应角度搜索
- 分布式通信层：模拟 RFM 反射内存数据传输
- 端到端测试：单机模拟完整计算管线

---

## 2. 系统架构

### 2.1 分布式部署架构

```
┌─────────────────────────────────────────────────────────────────┐
│                     BEST 控制室                                  │
│                                                                  │
│  ┌─────────────────────┐    RFM     ┌─────────────────────┐    │
│  │  PCS 服务器           │  ~0.3ms   │  ECRH-MC 服务器      │    │
│  │  ┌─────────────────┐ │ ────────→ │  ┌─────────────────┐ │    │
│  │  │ gpu_efit_server  │ │           │  │ray_tracing_server│ │    │
│  │  │                  │ │           │  │                  │ │    │
│  │  │ GPU-EFIT Solver  │ │           │  │ Ray Trace Engine │ │    │
│  │  │ ┌──────────────┐ │ │           │  │ ┌──────────────┐ │ │    │
│  │  │ │ R9700 GPU #1 │ │ │           │  │ │ R9700 GPU #2 │ │ │    │
│  │  │ └──────────────┘ │ │           │  │ └──────────────┘ │ │    │
│  │  └─────────────────┘ │           │  └─────────────────┘ │    │
│  └─────────────────────┘           └─────────────────────┘    │
│                                                                  │
│  ← PCS 团队管辖 →                    ← ECRH 团队管辖 →          │
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 软件模块划分

```
best-rtpc/
├── include/
│   ├── common/
│   │   ├── types.h            # 公共数据结构: EquilibriumData, BeamResult, ECRHTarget
│   │   ├── hip_check.h        # HIP 错误检查宏
│   │   ├── timer.h            # 高精度计时器
│   │   └── plasma_profiles.h  # 合成等离子体剖面生成器
│   ├── gpu_efit/
│   │   ├── gpu_efit.h         # GPU-EFIT 求解器 API
│   │   └── efit_kernels.h     # EFIT HIP kernel 声明
│   ├── ray_tracing/
│   │   ├── ray_tracing.h      # GPU 射线追踪 API
│   │   └── rt_kernels.h       # 射线追踪 HIP kernel 声明
│   └── distributed/
│       └── rfm_transport.h    # RFM 模拟传输层 API
├── src/
│   ├── common/
│   │   └── plasma_profiles.cpp    # Solovev 解析平衡 + 剖面生成
│   ├── gpu_efit/
│   │   ├── efit_kernels.hip       # ★ 5 个 EFIT HIP kernel 实现
│   │   ├── gpu_efit.hip           # GPU-EFIT 求解器主逻辑
│   │   ├── main.cpp               # gpu_efit_server 入口
│   │   └── CMakeLists.txt
│   ├── ray_tracing/
│   │   ├── rt_kernels.hip         # ★ 2 个射线追踪 HIP kernel 实现
│   │   ├── ray_tracing.hip        # GPU 射线追踪器主逻辑
│   │   ├── main.cpp               # ray_tracing_server 入口
│   │   └── CMakeLists.txt
│   └── distributed/
│       ├── rfm_transport.cpp      # TCP Socket 模拟 RFM
│       └── CMakeLists.txt
├── tests/
│   └── e2e_test.cpp               # 单进程端到端测试
├── docs/
│   └── 设计文档.md                 # 本文档
└── CMakeLists.txt                  # 顶层 CMake 构建
```

---

## 3. GPU-EFIT 模块

### 3.1 算法概述

基于 EAST P-EFIT（Huang et al., Nuclear Fusion 60, 2020）的 5 步 Grad-Shafranov 求解器：

```
Picard 迭代循环 (10–30 次):
  │
  ├── Green 函数边界条件:  ψ_bnd[i] = Σ_j G[i][j] × J[j]
  │
  ├── 构建右端项 RHS
  │
  └── 5 步 G-S 求解:
      Step 1: Ψ' = Q^T × RHS     (特征分解, tiled MatMul)
      Step 2: Transpose Ψ'        (共享内存转置)
      Step 3: 求解 M 个独立三对角系统  (并行前缀和)
      Step 4: Transpose X'        (共享内存转置)
      Step 5: X = Q × X'          (反向特征重构)
  │
  └── 收敛判断: max|Ψ_new - Ψ_old| < ε
```

### 3.2 HIP Kernel 清单

| Kernel | 功能 | Grid/Block | 优化策略 |
|--------|------|-----------|---------|
| `eigen_decomp_kernel` | Step 1/5: 矩阵乘法 | `(⌈M/32⌉, ⌈M/32⌉), (32,32)` | Tiled, LDS +1 padding, `#pragma unroll` |
| `matrix_transpose_kernel` | Step 2/4: 矩阵转置 | `(⌈M/32⌉, ⌈M/32⌉), (32,32)` | 共享内存避免全局内存 stride 访问 |
| `tridiag_solve_kernel` | Step 3: 三对角求解 | `M blocks, ⌈M/32⌉×32 threads` | 动态共享内存, 并行前缀和 |
| `green_boundary_kernel` | 边界条件 | `⌈N_bnd/256⌉, 256` | 4× 循环展开, Infinity Cache 友好 |
| `convergence_kernel` | 收敛检查 | `⌈N²/256⌉, 256` | 树归约 + atomicMax |
| `profiles_from_psi_kernel` | ψ→ne,Te,Bφ | `(⌈N/16⌉, ⌈N/16⌉), (16,16)` | 点并行, 无依赖 |

### 3.3 RDNA 4 / R9700 特定优化

1. **TILE_SIZE = 32**: 匹配 Wave32 执行模型（RDNA vs NVIDIA Warp32）
2. **LDS +1 padding**: `tile[32][33]` 消除 bank conflict（128 KB LDS per CU）
3. **Infinity Cache 利用**: 129×129 Green 矩阵 ≈ 33 MB ⊂ 64 MB Infinity Cache
4. **64 CU 并行度**: 129 个三对角系统 / 64 CU ≈ 2 轮（TITAN X 需 5 轮）
5. **FP32 精度**: 全部使用 float，与 P-EFIT 原始精度一致

### 3.4 性能目标

| 网格 | CPU 单核 | TITAN X (P-EFIT) | R9700 目标 |
|------|---------|------------------|-----------|
| 65×65 | 4 ms | ~3 ms | **< 0.8 ms** |
| 129×129 | 24 ms | ~5.5 ms | **< 1.5 ms** |
| 257×257 | 170 ms | N/A | **< 21 ms** |

---

## 4. GPU 射线追踪模块

### 4.1 物理模型

求解 Hamilton 射线方程描述的微波在磁化等离子体中的传播：

```
dr/dτ = -∂H/∂k / (∂H/∂ω)    (位置演化)
dk/dτ = +∂H/∂r / (∂H/∂ω)    (波矢演化)
```

其中 Hamilton 量 H(r, k, ω) = 0 为色散关系，依赖等离子体参数：
- n_e(R,Z): 电子密度 ← GPU-EFIT 输出
- T_e(R,Z): 电子温度 ← GPU-EFIT 输出
- B(R,Z):   磁场 ← GPU-EFIT 输出

### 4.2 两阶段自适应角度搜索

给定目标沉积位置 ρ_target（由 PCS 下发），搜索最优 Launcher 角度 (θ, φ)：

```
阶段 1: 粗搜索
  生成 10×10 = 100 个候选角度 (θ, φ) 覆盖全范围
  → 100 个 GPU 线程并行追踪 → 100 个 ρ_dep
  → 归约找到最小 |ρ_dep - ρ_target| 的角度

阶段 2: 精搜索
  在最佳粗角度 ±Δ 范围内生成 10×10 = 100 个细分角度
  → 100 个 GPU 线程并行追踪 → 100 个 ρ_dep
  → 归约找到全局最优角度
```

等效搜索精度 ≈ 10,000 均匀采样，但仅需 200 次射线追踪。

### 4.3 HIP Kernel 清单

| Kernel | 功能 | Thread 数 | 计算量 |
|--------|------|----------|-------|
| `ray_trace_kernel` | Hamilton ODE RK4 积分 | n_angles (100–10000) | ~10⁴ 步/线程, ~10⁶ FLOPs/线程 |
| `angle_optimize_kernel` | 并行归约找最优角度 | n_angles | 树归约 min\|ρ_dep - ρ_target\| |

### 4.4 射线追踪 kernel 内部流程

每个 GPU 线程追踪一条射线：

```
1. 从 Launcher 位置 (R₀, Z₀) 出发
2. 初始方向由 (θ, φ) 确定
3. 循环 ODE_STEPS (= 10000) 步:
   a. 双线性插值获取局部 ne, Te, B
   b. 计算色散关系 n²(ne, Te, B, ω)
   c. 计算吸收系数 α(ne, Te, B, ω)
   d. 更新剩余功率: P -= α × ds
   e. 计算折射: dk/ds ∝ ∇(n²)
   f. 推进位置: r += k × n × ds
   g. 记录最大吸收位置 → ρ_dep
   h. 提前退出: P < 5%
4. 输出: ρ_dep (沉积位置), η_cd (驱动效率)
```

### 4.5 性能目标

| 指标 | CPU rt-TORBEAM | R9700 目标 | 加速比 |
|------|---------------|-----------|-------|
| 单束正向追踪 | 1–2 ms | ~0.03 ms | ~50× |
| 12 束 × 100 角度 | 不可行 | < 0.5 ms | ∞ |
| 12 束 × 1000 角度 | ~15 s | < 0.5 ms | >30000× |

---

## 5. 分布式通信层

### 5.1 RFM 模拟

生产系统使用 RFM (Reflective Memory) 网卡（如 GE VMIPCI-5565），实现 PCS 与 ECRH 间的确定性低延迟数据传输。

本实现使用 TCP Socket 模拟 RFM 行为：

| 特性 | 真实 RFM | 本实现 (TCP) |
|------|---------|-------------|
| 延迟 | < 0.3 ms | ~0.1 ms (loopback) |
| 确定性 | 硬实时 | 尽力而为 |
| 带宽 | 2.12 Gbps | ~10 Gbps (localhost) |
| 接口 | 硬件映射内存 | Socket read/write |

### 5.2 数据传输协议

```
PCS (gpu_efit_server) → ECRH (ray_tracing_server):

  [Header]  int32[2]: {nr, nz}
  [Scalars] float32[8]: {R_min, R_max, Z_min, Z_max,
                          psi_axis, psi_boundary, R_axis, Z_axis}
  [Arrays]  float32[nr×nz] × 4: {psi, ne, Te, Bphi}

  129×129 网格: 2×4 + 8×4 + 4×129×129×4 = 266,280 bytes ≈ 260 KB
```

### 5.3 本地测试模式

`e2e_test` 使用 `RfmTransport::local_transfer()` 进行零拷贝 memcpy，在单进程中模拟完整管线。

---

## 6. 构建与运行

### 6.1 依赖

- **ROCm**: >= 6.0（含 HIP runtime）
- **CMake**: >= 3.21
- **GCC**: >= 10（C++17）
- **GPU**: AMD Radeon AI PRO R9700 (gfx1201)
  - 其他 RDNA 4 GPU 需修改 `GPU_TARGETS`

### 6.2 编译

```bash
cd best-rtpc
mkdir build && cd build
cmake .. -DROCM_PATH=/opt/rocm -DGPU_TARGETS=gfx1201
make -j$(nproc)
```

可选 GPU 架构参数（如使用其他 AMD GPU 测试）：
```bash
# gfx90a: MI210/MI250X, gfx942: MI300X, gfx1100: RX 7900 XTX
cmake .. -DGPU_TARGETS="gfx1100"
```

### 6.3 运行

**模式 1: 单进程端到端测试**

```bash
./e2e_test --grid 129 --iter 10 --beams 4
```

**模式 2: 分布式两进程测试**

终端 1（PCS GPU-EFIT 服务器）：
```bash
./gpu_efit_server --grid 129 --iter 10 --port 50051
```

终端 2（ECRH 射线追踪服务器）：
```bash
./ray_tracing_server --port 50051 --beams 4
```

### 6.4 命令行参数

| 参数 | 说明 | 默认值 | 可选值 |
|------|------|-------|-------|
| `--grid` | EFIT 网格尺寸 | 129 | 65, 129, 257 |
| `--iter` | Picard 迭代次数 | 10 | 1–30 |
| `--beams` | 活跃 ECRH 束数 | 4 | 1–12 |
| `--port` | RFM 通信端口 | 50051 | 任意可用端口 |

---

## 7. 与设计方案的对应关系

本项目实现了 `AMD_R9700_实时等离子体计算平台设计.md` V1.1 中描述的：

| 设计方案章节 | 本项目实现 |
|-------------|-----------|
| §3 GPU-EFIT 设计 | `src/gpu_efit/` — 完整 5 步 G-S 求解器 |
| §3.2 HIP Kernel 示例 | `efit_kernels.hip` — 6 个 kernel |
| §4 GPU 射线追踪设计 | `src/ray_tracing/` — Hamilton ODE + 角度优化 |
| §4.3 软件架构 | `rt_kernels.hip` — 2 个 kernel |
| §5 分布式部署架构（推荐方案 B）| `src/distributed/` — TCP 模拟 RFM |
| §5.2 数据流路径 | `e2e_test.cpp` — 端到端验证 |

### 7.1 简化与待完善项

本参考实现对以下方面进行了简化：

| 项目 | 生产级要求 | 本实现 |
|------|-----------|-------|
| 平衡模型 | 真实诊断数据输入 | Solovev 解析平衡 |
| Green 函数 | 精确 Biot-Savart 积分 | 简化 1/r 近似 |
| 特征矩阵 Q | 离线数值分解 | 离散正弦变换基 |
| 色散关系 | 完整热等离子体色散 | 冷等离子体 O 模近似 |
| RFM 通信 | 硬件 RFM 网卡 | TCP Socket 模拟 |
| 降级策略 | CPU fallback + watchdog | 未实现 |
| 混合精度 | FP16/FP32 自适应 | 纯 FP32 |
| AI 初始化 | 神经网络预测初始 ψ | 未实现 |

---

## 8. 端到端数据流

```
诊断数据 (Mirnov/ECE/Thomson)
    │
    ▼
┌────────────────────────────────────────┐
│ gpu_efit_server (PCS 服务器, GPU #1)    │
│                                         │
│  h_J_plasma ──hipMemcpy→ d_J_plasma    │
│       │                                 │
│  ┌────┴─── Picard Loop ──────────┐     │
│  │  green_boundary_kernel         │     │
│  │  eigen_decomp_kernel (Q^T×RHS) │     │
│  │  matrix_transpose_kernel       │     │
│  │  tridiag_solve_kernel          │     │
│  │  matrix_transpose_kernel       │     │
│  │  eigen_decomp_kernel (Q×X')    │     │
│  │  convergence_kernel            │     │
│  └────────────────────────────────┘     │
│       │                                 │
│  profiles_from_psi_kernel               │
│       │                                 │
│  d_psi/d_ne/d_Te/d_Bphi ──hipMemcpy→ host │
└────────────────┬───────────────────────┘
                 │
            RFM 传输 (~0.3 ms)
            {nr, nz, scalars, psi, ne, Te, Bphi}
                 │
                 ▼
┌────────────────────────────────────────┐
│ ray_tracing_server (ECRH-MC, GPU #2)   │
│                                         │
│  host ──hipMemcpyAsync→ d_psi/ne/Te/B  │
│       │                                 │
│  ┌────┴─── Per Beam Loop ────────┐     │
│  │  生成粗角度网格 (10×10)         │     │
│  │  ray_trace_kernel (100 线程)   │     │
│  │  angle_optimize_kernel         │     │
│  │  生成精角度网格 (10×10)         │     │
│  │  ray_trace_kernel (100 线程)   │     │
│  │  angle_optimize_kernel         │     │
│  └────────────────────────────────┘     │
│       │                                 │
│  输出: (θ_opt, φ_opt) per beam          │
│       │                                 │
│  EtherCAT → Launcher 驱动              │
└────────────────────────────────────────┘
```

---

## 9. 未来扩展路线

### 9.1 短期 (6 个月)

- [ ] 接入真实诊断数据格式（替换合成等离子体）
- [ ] 实现 CPU 降级策略（GPU watchdog + fallback 查找表）
- [ ] 混合精度：FP16 加速 80% 迭代，FP32 精修最后 20%

### 9.2 中期 (1 年)

- [ ] 集成真实 RFM 硬件驱动（GE VMIPCI-5565）
- [ ] AI 辅助初始化：训练 EFIT-NN 将迭代次数从 10 减至 3–5
- [ ] 支持 257×257 实时（9 ms 目标，用于高分辨率场景）

### 9.3 长期 (2 年)

- [ ] 迁移到 AMD Instinct MI 系列（如需 FP64 射线追踪）
- [ ] 实现完整热等离子体色散关系
- [ ] 12 束全并行优化（当前为串行逐束）
- [ ] 闭环集成 BEST PCS 控制框架

---

## 附录 A: 关键数据结构

### EquilibriumData（GPU-EFIT 输出 / 射线追踪输入）

```cpp
struct EquilibriumData {
    int nr, nz;                    // 网格维度
    float R_min, R_max;            // 径向范围 [m]
    float Z_min, Z_max;            // 纵向范围 [m]
    float* psi;                    // 极向磁通 ψ(R,Z) [nr×nz]
    float* ne;                     // 电子密度 [m⁻³]
    float* Te;                     // 电子温度 [eV]
    float* BR, *BZ, *Bphi;        // 磁场分量 [T]
    float psi_axis, psi_boundary;  // 磁轴/边界 ψ 值
    float R_axis, Z_axis;          // 磁轴位置 [m]
};
```

### ECRHTarget（PCS → ECRH 控制指令）

```cpp
struct ECRHTarget {
    int num_beams;           // 活跃束数 (≤12)
    float rho_target[12];    // 各束目标沉积 ρ
    float P_request[12];     // 各束请求功率 [MW]
};
```

### BeamResult（射线追踪输出 → Launcher 控制）

```cpp
struct BeamResult {
    float theta_opt, phi_opt;  // 最优 Launcher 角度 [rad]
    float rho_dep;             // 实际沉积位置 ρ
    float delta_rho;           // 沉积宽度
    float eta_cd;              // ECCD 驱动效率
};
```

---

## 附录 B: HIP 编程范式参考

本项目的 HIP kernel 编写参考了 `rocm-systems` 仓库中的典型模式：

| 模式 | 参考文件 | 在本项目中的应用 |
|------|---------|---------------|
| Tiled MatMul + 共享内存 | `rocprofiler-compute/sample/mat_mul_max.hip` | `eigen_decomp_kernel` |
| 共享内存转置 | `hip-tests/samples/2_Cookbook/3_shared_memory/` | `matrix_transpose_kernel` |
| 动态共享内存 | `hip/docs/tools/example_codes/dynamic_shared_memory_device.hip` | `tridiag_solve_kernel` |
| 异步流 + hipMemcpyAsync | `hip/docs/tools/example_codes/async_kernel_execution.hip` | 全部 kernel 启动 |
| HIP_CHECK 错误处理 | `hip/docs/tools/example_codes/add_kernel.hip` | 所有 HIP API 调用 |
| CMake HIP LANGUAGE | `hip-tests/samples/2_Cookbook/22_cmake_hip_lang/` | `CMakeLists.txt` |
